#!/usr/bin/env node
/**
 * Fetch newest arXiv entries for demo categories and generate static JSON + HTML.
 *
 * Usage:
 *   node scripts/fetch_arxiv.mjs
 *
 * Notes:
 * - Uses https://export.arxiv.org/api/query
 * - Writes to data/*.json, categories/*.html, papers/*.html, and updates index.html
 */

import fs from 'node:fs/promises';
import path from 'node:path';

const BASE = 'https://export.arxiv.org/api/query';
const CATEGORIES = [
  { code: 'cs.AI', name: 'Artificial Intelligence (cs.AI)' },
  { code: 'cs.AR', name: 'Hardware Architecture (cs.AR)' }
];

function escHtml(s=''){
  return String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}

function trimWs(s=''){
  return String(s).replace(/\s+/g,' ').trim();
}

function toPdfUrl(absUrl, links){
  const pdf = links.find(l => l.type === 'application/pdf');
  if (pdf?.href) return pdf.href;
  // fallback
  return absUrl.replace('/abs/','/pdf/') + '.pdf';
}

function parseAtom(xmlText){
  // Minimal XML extraction (sufficient for arXiv Atom in this project).
  // Not a general-purpose XML parser.
  const entryRe = /<entry>([\s\S]*?)<\/entry>/g;
  const entries = [];
  let m;
  while((m = entryRe.exec(xmlText))){
    const block = m[1];
    const getTag = (tag) => {
      const re = new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`);
      const mm = re.exec(block);
      return mm ? trimWs(mm[1]) : '';
    };

    const id = getTag('id');
    const title = getTag('title');
    const published = getTag('published');
    const updated = getTag('updated');
    const summary = getTag('summary');

    const authorNames = [...block.matchAll(/<author>[\s\S]*?<name>([\s\S]*?)<\/name>[\s\S]*?<\/author>/g)]
      .map(x => trimWs(x[1]))
      .filter(Boolean);

    const links = [...block.matchAll(/<link\s+([^>]+?)\/>/g)].map(x => {
      const attrs = x[1];
      const getAttr = (name) => {
        const r = new RegExp(`${name}="([^"]*)"`);
        const mm = r.exec(attrs);
        return mm ? mm[1] : '';
      };
      return {
        href: getAttr('href'),
        rel: getAttr('rel'),
        type: getAttr('type'),
        title: getAttr('title')
      };
    });

    const absUrl = id.replace('http://','https://');
    const pdfUrl = toPdfUrl(absUrl, links);
    const arxivId = (absUrl.match(/abs\/(.+)$/)?.[1] || '').trim();

    entries.push({
      title,
      absUrl,
      pdfUrl,
      published,
      updated,
      authors: authorNames,
      summary,
      arxivId
    });
  }
  return entries;
}

function bibtexFor(p){
  const year = (p.published || p.updated || '').slice(0,4) || '????';
  const keyBase = (p.authors?.[0]?.split(' ')?.slice(-1)[0] || 'arxiv') + year;
  const safeKey = keyBase.replace(/[^a-zA-Z0-9_]/g,'');
  return `@misc{${safeKey},\n`+
         `  title        = {${p.title}},\n`+
         `  author       = {${(p.authors||[]).join(' and ')}},\n`+
         `  year         = {${year}},\n`+
         `  eprint       = {${p.arxivId}},\n`+
         `  archivePrefix= {arXiv},\n`+
         `  primaryClass = {${p.primaryCategory || ''}},\n`+
         `  url          = {${p.absUrl}}\n`+
         `}`;
}

function plainCitationFor(p){
  const year = (p.published || p.updated || '').slice(0,4) || 'n.d.';
  const authors = (p.authors||[]).join(', ') || 'Unknown authors';
  return `${authors} (${year}). ${p.title}. arXiv:${p.arxivId}. ${p.absUrl}`;
}

function layout({title, activeNav, body}){
  const navLink = (href, label, key) => `<a href="${href}" class="${activeNav===key?'active':''}">${label}</a>`;
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escHtml(title)} • arXiv CS Daily</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <script defer src="../assets/site.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <div class="brand">
        <a href="../index.html" class="title">arXiv CS Daily</a>
        <div class="subtitle">Static demo built from arXiv Atom API (prefetched to avoid CORS)</div>
      </div>
      <nav class="nav">
        ${navLink('../index.html','Home','home')}
        ${navLink('../categories/cs.AI.html','cs.AI','cs.AI')}
        ${navLink('../categories/cs.AR.html','cs.AR','cs.AR')}
      </nav>
    </div>
  </header>

  <main class="container">
    ${body}

    <div class="footer">
      <div class="note">Data source: <a href="https://export.arxiv.org/api/query">arXiv API</a>. Pages are generated by <code>scripts/fetch_arxiv.mjs</code>.</div>
    </div>
  </main>
</body>
</html>`;
}

function layoutRoot({title, activeNav, body}){
  const navLink = (href, label, key) => `<a href="${href}" class="${activeNav===key?'active':''}">${label}</a>`;
  return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${escHtml(title)} • arXiv CS Daily</title>
  <link rel="stylesheet" href="assets/styles.css" />
  <script defer src="assets/site.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <div class="brand">
        <a href="index.html" class="title">arXiv CS Daily</a>
        <div class="subtitle">Static demo built from arXiv Atom API (prefetched to avoid CORS)</div>
      </div>
      <nav class="nav">
        ${navLink('index.html','Home','home')}
        ${navLink('categories/cs.AI.html','cs.AI','cs.AI')}
        ${navLink('categories/cs.AR.html','cs.AR','cs.AR')}
      </nav>
    </div>
  </header>

  <main class="container">
    ${body}

    <div class="footer">
      <div class="note">Data source: <a href="https://export.arxiv.org/api/query">arXiv API</a>. Pages are generated by <code>scripts/fetch_arxiv.mjs</code>.</div>
    </div>
  </main>
</body>
</html>`;
}

async function ensureDirs(){
  await fs.mkdir('data', { recursive: true });
  await fs.mkdir('categories', { recursive: true });
  await fs.mkdir('papers', { recursive: true });
  await fs.mkdir('assets', { recursive: true });
  await fs.mkdir('scripts', { recursive: true });
}

async function fetchCategory(cat){
  const url = `${BASE}?search_query=cat:${encodeURIComponent(cat)}&sortBy=submittedDate&sortOrder=descending&max_results=3`;
  const res = await fetch(url, { headers: { 'User-Agent': 'arxiv-cs-daily-static-demo' }});
  if(!res.ok) throw new Error(`Fetch failed ${res.status} for ${cat}`);
  const xml = await res.text();
  return { url, xml };
}

function categoryPageHtml(catCode, catName, papers){
  const items = papers.map((p, idx) => {
    const detail = `../papers/${catCode}-${idx+1}.html`;
    const authors = (p.authors||[]).join(', ');
    return `
      <div class="paper-item">
        <div class="paper-title"><a href="${detail}">${escHtml(p.title)}</a></div>
        <div class="paper-meta">
          <span class="pill"><strong>Published</strong> ${escHtml(p.published?.replace('T',' ').replace('Z',' UTC') || '—')}</span>
          <span class="pill"><strong>Updated</strong> ${escHtml(p.updated?.replace('T',' ').replace('Z',' UTC') || '—')}</span>
        </div>
        <div class="muted" style="margin-bottom:10px"><strong>Authors:</strong> ${escHtml(authors || '—')}</div>
        <p class="paper-abstract">${escHtml(p.summary || '')}</p>
        <div class="paper-actions">
          <a class="btn small primary" href="${detail}">Details</a>
          <a class="btn small" href="${escHtml(p.pdfUrl)}" target="_blank" rel="noopener">PDF</a>
          <a class="btn small" href="${escHtml(p.absUrl)}" target="_blank" rel="noopener">arXiv</a>
        </div>
      </div>`;
  }).join('\n');

  return layout({
    title: `${catCode} Daily`,
    activeNav: catCode,
    body: `
      <div class="card">
        <div class="card-body">
          <h2>${escHtml(catName)}</h2>
          <div class="muted">Newest 3 submissions (sorted by submittedDate, descending).</div>
        </div>
        ${items}
      </div>
    `
  });
}

function paperDetailHtml(catCode, idx, p){
  const authors = (p.authors||[]).join(', ');
  const bib = bibtexFor(p);
  const plain = plainCitationFor(p);

  const body = `
    <div class="card">
      <div class="card-body">
        <div class="pill"><strong>Category</strong> ${escHtml(catCode)}</div>
        <h2 style="margin-top:10px">${escHtml(p.title)}</h2>
        <div class="muted"><strong>Authors:</strong> ${escHtml(authors || '—')}</div>

        <div class="kv">
          <div class="k">Published</div><div class="v">${escHtml(p.published?.replace('T',' ').replace('Z',' UTC') || '—')}</div>
          <div class="k">Updated</div><div class="v">${escHtml(p.updated?.replace('T',' ').replace('Z',' UTC') || '—')}</div>
          <div class="k">arXiv</div><div class="v"><a href="${escHtml(p.absUrl)}" target="_blank" rel="noopener">${escHtml(p.arxivId || p.absUrl)}</a></div>
          <div class="k">PDF</div><div class="v"><a href="${escHtml(p.pdfUrl)}" target="_blank" rel="noopener">Open PDF</a></div>
        </div>

        <h3>Abstract</h3>
        <p class="paper-abstract">${escHtml(p.summary || '')}</p>

        <h3 style="margin-top:18px">Citations</h3>
        <div class="citations">
          <div class="cite-block">
            <div class="cite-head">
              <div class="label">Plain</div>
              <button class="btn small" data-copy-target="#plain-${catCode}-${idx}">Copy</button>
            </div>
            <pre id="plain-${catCode}-${idx}">${escHtml(plain)}</pre>
          </div>
          <div class="cite-block">
            <div class="cite-head">
              <div class="label">BibTeX</div>
              <button class="btn small" data-copy-target="#bib-${catCode}-${idx}">Copy</button>
            </div>
            <pre id="bib-${catCode}-${idx}">${escHtml(bib)}</pre>
          </div>
        </div>

        <div class="paper-actions" style="margin-top:16px">
          <a class="btn" href="../categories/${catCode}.html">← Back to ${escHtml(catCode)}</a>
          <a class="btn primary" href="${escHtml(p.pdfUrl)}" target="_blank" rel="noopener">Open PDF</a>
        </div>
      </div>
    </div>
  `;

  return layout({ title: p.title, activeNav: catCode, body });
}

function homeHtml(all){
  const cards = all.map(({code, name, papers})=>{
    const list = papers.map((p, i)=>{
      const detail = `papers/${code}-${i+1}.html`;
      return `<div class="paper-item">
        <div class="paper-title"><a href="${detail}">${escHtml(p.title)}</a></div>
        <div class="paper-meta">
          <span class="pill"><strong>Published</strong> ${escHtml(p.published?.slice(0,10) || '—')}</span>
          <span class="pill"><strong>Updated</strong> ${escHtml(p.updated?.slice(0,10) || '—')}</span>
        </div>
        <div class="paper-actions">
          <a class="btn small primary" href="${detail}">Details</a>
          <a class="btn small" href="${escHtml(p.pdfUrl)}" target="_blank" rel="noopener">PDF</a>
        </div>
      </div>`;
    }).join('');

    return `<div class="card">
      <div class="card-body">
        <h2>${escHtml(name)}</h2>
        <div class="paper-actions">
          <a class="btn primary" href="categories/${code}.html">Open category page</a>
          <a class="btn" href="data/${code}.json">View JSON</a>
        </div>
      </div>
      ${list}
    </div>`;
  }).join('\n');

  return layoutRoot({
    title: 'Home',
    activeNav: 'home',
    body: `
      <div class="note" style="margin-bottom:16px">
        This demo is a <strong>static</strong> website. To avoid browser CORS issues with the arXiv API, data is fetched ahead of time by <code>scripts/fetch_arxiv.mjs</code> and saved into <code>data/*.json</code>, and per-paper HTML pages are generated.
      </div>
      <div class="grid cols-2">
        ${cards}
      </div>
    `
  });
}

async function main(){
  await ensureDirs();

  const all = [];
  for (const c of CATEGORIES){
    const { xml } = await fetchCategory(c.code);
    const entries = parseAtom(xml);

    // write JSON
    await fs.writeFile(path.join('data', `${c.code}.json`), JSON.stringify({
      category: c.code,
      fetchedAt: new Date().toISOString(),
      count: entries.length,
      papers: entries
    }, null, 2));

    // category page
    await fs.writeFile(path.join('categories', `${c.code}.html`), categoryPageHtml(c.code, c.name, entries));

    // paper pages (stable filenames as required)
    for (let i=0;i<entries.length;i++){
      const p = entries[i];
      await fs.writeFile(path.join('papers', `${c.code}-${i+1}.html`), paperDetailHtml(c.code, i+1, p));
    }

    all.push({ code: c.code, name: c.name, papers: entries });
  }

  await fs.writeFile('index.html', homeHtml(all));

  console.log('Generated index.html, categories/*.html, papers/*.html, data/*.json');
}

main().catch(err=>{
  console.error(err);
  process.exit(1);
});
